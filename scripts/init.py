'''
init.py
This Python script contains all the function to initialize a docker-machine on a computer
/!\ Please, do not edit this file /!\
'''

import docker
import sys
import subprocess
import socket
import os
import requests
import psutil
import config
import restcall
import common

'''
ON WORKING :
    - Detect services' ports needs (Imad) --> Changed
    - Send running configuration / Send configuration
    - Arguments

Libraries :
    - docker
    - requests
    - psutil
'''

# Installation checking
# Checks if docker, docker-machine and virtualbox are installed
# @return : True if all the tools are installed, false otherwise
def check_installation():
    try:
        subprocess.check_output(["docker", "version"])
        subprocess.check_output(["docker-machine", "version"])
        subprocess.check_output(["virtualbox", "--help"])
        return True
    except Exception:
        return False

# Get the information given by inspect of a docker-machine
# @param name : The name of the docker-machine to get the configuration
# @return : The inspect result of the docker-machine in a string array, '' if it does not exist
def check_docker_machine(name):
    cmd = "docker-machine inspect " + name
    try:
        subprocess.check_output(cmd.split()).split('\n')
        return True
    except Exception :
        return False

# Start a docker-machine
# @param name : The name of the docker-machine to start_docker_machine
# @return : Nothing
def start_docker_machine(name):
    cmd = "docker-machine start " + name
    try:
        subprocess.check_output(cmd.split())
    except Exception:
        # Not a critical exception : docker-machine already started
        return

# Create a docker-machine
# This function will ask to the user if he want to give a specific configuration to the docker-machine
# TODO No interaction with user in a function ?
# @param name : The name of the docker-machine to create
# @return : A dict containing the configuration of the docker machine, with 3 fields : ram, cpu and disk (-1 if not limited)
def create_docker_machine(name):
    limited_dm = False
    if common.query_yes_no("Define a docker-machine with limited ressources ?"):
        limited_dm = True
        ram = common.query_int("\tRAM (Mo) : ")
        cpu = common.query_int("\tNumber of CPU : ")
        disk = common.query_int("\tDisk space (Go) : ")
        cmd_create_dm = "docker-machine create -d virtualbox --virtualbox-disk-size " + str(disk) + " --virtualbox-cpu-count " + str(cpu) + " --virtualbox-memory " + str(ram) + " " + name
        config = {config.KEY_CONFIG_RAM: str(ram), config.KEY_CONFIG_CPU: str(cpu), config.KEY_CONFIG_HDD: str(disk)}
    else:
        cmd_create_dm = "docker-machine create -d virtualbox " + name
        config = {config.KEY_CONFIG_RAM: "-1", config.config.KEY_CONFIG_CPU: "-1", config.KEY_CONFIG_HDD: "-1"}

    ps_creation = subprocess.Popen(cmd_create_dm.split(), stdout=subprocess.PIPE)
    create_dm_out, check_dm_error = ps_creation.communicate()
    print "Docker-machine created."
    return config

# Switch the current docker-machine to another one
# @param name : The name of the docker-machine to switch to
# @return : A docker.Client object using the docker-machine
def switch_dm(name):
    cmd_env = "docker-machine env " + config.DOCKER_MACHINE_NAME
    try:
        result_env = [l for l in subprocess.check_output(cmd_env.split()).split('\n') if not l.startswith('#')]
    except Exception:
        return

    for c in result_env:
        if c == '':
            continue
        current = c.split(' ')[1]
        os.environ[current.split('=')[0]] = current.split('=')[1].replace('"', '')
    return docker.from_env()

# Get a free port on the host
# @return : Integer corresponding to the port number
def get_free_port():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("",0))
    s.listen(1)
    port = s.getsockname()[1]
    s.close()
    return port

# Bind a VirtualBox port on the physical host
# @param portdm : The docker-machine's port to bind on the host
# @param porthost : The corresponding port host to access to the docker-machine's one
# @param protocol : Protocol to use on the port
# @return : (bool, String) True or False according to the succes of the operation, with the name of the rule
def binding_rule_create(porthost, portdm, protocol):
    rule_name = "rule" + str(porthost)
    cmd = "VBoxManage controlvm " + config.DOCKER_MACHINE_NAME + " natpf1 " + rule_name + "," + str(protocol) + ",," + str(porthost) + ",," + str(portdm)
    # VBoxManage controlvm dm-iaas natpf1 rule80,tcp,,80,,80

    try:
        ps_creation = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        cmd_bind_out, cmd_bind_error = ps_creation.communicate()
        return (True, rule_name)
    except Exception:
        return (False, rule_name)

# Delete a binding rule from the docker-machine to the host
# @param rule_name : The name of the rule to delete
# @return : True or False according to the succes of the remove
def binding_rule_remove(rule_name):
    cmd = "VBoxManage controlvm " + config.DOCKER_MACHINE_NAME + " natpf1 delete " + rule_name

    try:
        ps_creation = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        cmd_bind_out, cmd_bind_error = ps_creation.communicate()
        return True
    except Exception:
        return False

def main():
    if check_installation():
        if not check_docker_machine(config.DOCKER_MACHINE_NAME):
            print "Before creating a new docker-machine, you need to register to send its configuration to the manager."
            if not common.log_in(3):
                sys.exit(1)
            restcall.send_config(create_docker_machine(config.DOCKER_MACHINE_NAME))
        else:
            start_docker_machine(config.DOCKER_MACHINE_NAME)
        client = switch_dm(config.DOCKER_MACHINE_NAME)
        binding_rule_create(2377, 2377, "tcp")
        binding_rule_create(7946, 7946, "tcp")
        binding_rule_create(7946, 7946, "udp")
        binding_rule_create(4789, 4789, "udp")
    else:
        print "You first need to install docker, docker-machine and VirtualBox."
        sys.exit(1)

    print "Done."

if __name__ == "__main__":
    main()
