'''
restcall.py
This Python script contains all the function to call the cocass rest API
/!\ Please, do not edit this file /!\
'''

import common
import requests
import json
import docker
import psutil
import subprocess

# Definition of all URLs
URL_USER_CREATE = common.SERVER_URL + "User/new"
URL_USER_LOGIN = common.SERVER_URL + "User/login"
URL_PRODIVER_UPDATE = common.SERVER_URL + 'Provider/update'
URL_PROVIDER_NEW = common.SERVER_URL + "Provider/new"
URL_PROVIDER_DELETE = common.SERVER_URL + "Provider/delete"
URL_SWARM = common.SERVER_URL + "swarm"

# Creates a new user
# @param username
# @param password
# @param firstname
# @param lastname
# @return : True or False according to the success of the creation
def create_user((username, password, firstname, lastname)):
    headers = {'content-type': 'application/json'}
    payload = {'username': username, 'password': password, 'firstname': firstname, 'lastname':lastname}
    r = requests.post(URL_USER_CREATE, data=json.dumps(payload), headers=headers)
    return r.status_code == common.CODE_SUCCESS


# User logging to the website
# @param attempts : The number of logging attempts
# @return : True or False, accordig to the success of the logging, with the last used logs
def log_in(attempts):
    t = attempts
    while t > 0:
        logs = common.get_logs()
        if not api_log_in(logs):
            t -= 1
            print "Log in failed. Attempts remaining : " + str(t)
        else:
            print "Login successfull."
            return (True, logs)
    return (False, logs)

# Login to the server
# @param (username, password) : The logs of the user
# @return : True or False according to the success of the authentication
def api_log_in((username, password)):
    headers = {'content-type': 'application/json'}
    payload = {'username': username, 'password': password}
    r = requests.post(URL_USER_LOGIN, data=json.dumps(payload), headers=headers)
    return r.status_code == common.CODE_SUCCESS

# Send the current system configuration
# @return : True or False according to the success of the sending
def send_current_config(username, password):
    # Detect wich CPU is used by the docker-machine -> Quite complicated : need to ssh to the docker-machine, and parse and calcul based on /proc/stat
    cmd_disk = "docker-machine ssh " + common.DOCKER_MACHINE_NAME + " df /dev/sda1"
    r = subprocess.check_output(cmd_disk.split()).split('\n')
    disk = int(filter(None, r[1].split(' '))[2])

    cmd_ram = "docker-machine ssh " + common.DOCKER_MACHINE_NAME + " free -m"
    r = subprocess.check_output(cmd_ram.split()).split('\n')
    ram = int(filter(None, r[1].split(' '))[3])

    cpu_usage = psutil.cpu_percent(interval=1, percpu=True) # CPU usage of the computer, not the docker-machine
    cpu_average = sum(cpu_usage) / len(cpu_usage)

    headers = {'content-type': 'application/json'}
    payload = {'username': username, 'password': password, 'storageCurrent': disk, 'memoryCurrent': ram, 'cpuCurrent': cpu_average}
    r = requests.post(URL_PRODIVER_UPDATE, data=json.dumps(payload), headers=headers)
    return r.status_code == common.CODE_SUCCESS

# TODO
# Send the configuration to the common.SERVER_URL
# @param config : A dict with KEY_CONFIG_CPU, common.KEY_CONFIG_RAM and common.KEY_CONFIG_HDD representing the configuration of the docker-machine to register
# @return : True or False according to the success of the registration
def send_config(config, username, password):
    # CPU core
    cpu_nb = psutil.cpu_count()
    # Total RAM PC
    ram = psutil.virtual_memory()[1]
    # HDD PC (used/free)
    hdd_total, hdd_percent = psutil.disk_usage('/')[0], psutil.disk_usage('/')[3]

    headers = {'content-type': 'application/json'}
    payload = {'cpuLimit': config[common.KEY_CONFIG_CPU], 'memoryLimit': config[common.KEY_CONFIG_RAM], 'storageLimit': config[common.KEY_CONFIG_HDD], 'username': username, 'password': password, 'cpuMachine': cpu_nb, 'memoryMachine': ram, 'storageMachine': hdd_total, 'storageUsedPercent': hdd_percent}
    r = requests.post(URL_PROVIDER_NEW, data=json.dumps(payload), headers=headers)

    return r.status_code == common.CODE_SUCCESS

# Unregister a worker to the server
# @param (username, password) : A tupple representing the username and the password of the worker
# @return : True or False according to the success of the request
def remove_worker((username, password)):
    headers = {'content-type': 'application/json'}
    payload = {'username': username, 'password': password}
    r = requests.post(URL_PROVIDER_DELETE, data=json.dumps(payload), headers=headers)
    return r.status_code == common.CODE_SUCCESS

# Get the token of a swarm from the server
# @return : The token of the currently running swarm
def swarm_token():
    r = requests.get(URL_SWARM)
    return r.json()['swarmToken']
